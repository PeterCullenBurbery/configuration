package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
	"gopkg.in/yaml.v3"
)

const moduleName = "MyModule"
const moduleDescription = "PowerShell utilities for configuring Windows systems, managing environments, customizing time and date settings, and automating administrative tasks."

// Recursively extract all PowerShell functions
func extractFunctions(node *yaml.Node, functions *[]string) {
	if node.Kind == yaml.MappingNode {
		for i := 0; i < len(node.Content); i += 2 {
			valNode := node.Content[i+1]
			if valNode.Kind == yaml.ScalarNode && strings.HasPrefix(strings.TrimSpace(valNode.Value), "function") {
				*functions = append(*functions, strings.TrimSpace(valNode.Value))
			} else {
				extractFunctions(valNode, functions)
			}
		}
	} else if node.Kind == yaml.SequenceNode {
		for _, item := range node.Content {
			extractFunctions(item, functions)
		}
	}
}

// Backup to a fixed .bak file (overwrite if it already exists), then write new file
func overwriteWithSingleBackup(path string, content string) error {
	if _, err := os.Stat(path); err == nil {
		backupPath := path + ".bak"
		_ = os.Remove(backupPath) // delete old backup if exists
		if err := os.Rename(path, backupPath); err != nil {
			return fmt.Errorf("‚ùå Failed to back up existing file: %w", err)
		}
		fmt.Printf("üîÅ Existing file backed up: %s ‚Üí %s\n", path, backupPath)
	}
	return os.WriteFile(path, []byte(content), 0644)
}

// Write file with UTF-8 BOM for PowerShell compatibility
func writeUtf8WithBom(path string, content string) error {
	utf8Bom := []byte{0xEF, 0xBB, 0xBF}
	data := append(utf8Bom, []byte(content)...)
	return overwriteWithSingleBackup(path, string(data))
}

// Write collected functions into a .psm1 file
func writePsm1(functions []string, path string) error {
	content := strings.Join(functions, "\n\n")
	return writeUtf8WithBom(path, content)
}

// Generate PowerShell module manifest (.psd1)
func writePsd1(path string, moduleName string, description string, guid string) error {
	content := fmt.Sprintf(`# 
# Module manifest for module '%s'
#
# Generated by: Peter Burbery
# Generated on: %s
@
{
RootModule = '%s.psm1'
ModuleVersion = '1.0.0'
GUID = '%s'
Author = 'Peter Cullen Burbery'
CompanyName = 'Unknown'
Copyright = '(c) Peter Burbery. Some rights reserved.'
Description = '%s'
FunctionsToExport = '*'
CmdletsToExport = '*'
VariablesToExport = '*'
AliasesToExport = '*'
PrivateData = @{
    PSData = @{
    }
}
}
`, moduleName, time.Now().Format("1/2/2006"), moduleName, guid, description)

	return writeUtf8WithBom(path, content)
}

func main() {
	homeDir, _ := os.UserHomeDir()

	// Input YAML file path
	yamlPath := filepath.Join(homeDir, "Desktop", "GitHub-repositories", "configuration", "debugging", "yaml", "scripts.yaml")

	// Output directory next to YAML path
	outputDir := filepath.Join(homeDir, "Desktop", "GitHub-repositories", "configuration", "debugging", "yaml", "output")
	psm1Path := filepath.Join(outputDir, moduleName+".psm1")
	psd1Path := filepath.Join(outputDir, moduleName+".psd1")

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		panic(fmt.Errorf("‚ùå Failed to create output directory: %w", err))
	}

	// Read YAML contents
	yamlBytes, err := os.ReadFile(yamlPath)
	if err != nil {
		panic(fmt.Errorf("‚ùå Failed to read YAML: %w", err))
	}

	// Parse YAML into root node
	var root yaml.Node
	if err := yaml.Unmarshal(yamlBytes, &root); err != nil {
		panic(fmt.Errorf("‚ùå Failed to parse YAML: %w", err))
	}

	// Extract PowerShell functions
	var functions []string
	if len(root.Content) > 0 {
		extractFunctions(root.Content[0], &functions)
	}

	// Report function count
	if len(functions) == 0 {
		fmt.Println("‚ö†Ô∏è No PowerShell functions found in YAML.")
	} else {
		fmt.Printf("‚úÖ %d PowerShell functions extracted.\n", len(functions))
	}

	// Write .psm1 file with BOM
	if err := writePsm1(functions, psm1Path); err != nil {
		panic(fmt.Errorf("‚ùå Failed to write .psm1: %w", err))
	}

	// Generate GUID for manifest
	guid := uuid.New().String()

	// Write .psd1 file with BOM
	if err := writePsd1(psd1Path, moduleName, moduleDescription, guid); err != nil {
		panic(fmt.Errorf("‚ùå Failed to write .psd1: %w", err))
	}

	fmt.Println("‚úÖ Module files written to:", outputDir)
}
