configuration:
  explorer:
    dark mode:
      on: |
        function Set-DarkMode {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"

                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set dark mode (0 = Dark, DWORD)
                Set-ItemProperty -Path $regPath -Name AppsUseLightTheme   -Value 0 -Type DWord
                Set-ItemProperty -Path $regPath -Name SystemUsesLightTheme -Value 0 -Type DWord

                Write-Host "âœ… Dark mode registry values set (AppsUseLightTheme & SystemUsesLightTheme = 0)."

                if (-not $NoRestart) {
                    # Restart Explorer so the new theme is read
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply Dark Mode."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to set Dark Mode: $_"
            }
        }
      off: |
        function Set-LightMode {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"

                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set light mode (1 = Light, DWORD)
                Set-ItemProperty -Path $regPath -Name AppsUseLightTheme   -Value 1 -Type DWord
                Set-ItemProperty -Path $regPath -Name SystemUsesLightTheme -Value 1 -Type DWord

                Write-Host "âœ… Light mode registry values set (AppsUseLightTheme & SystemUsesLightTheme = 1)."

                if (-not $NoRestart) {
                    # Restart Explorer so the new theme is read
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply Light Mode."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to set Light Mode: $_"
            }
        }
    start menu on left:
      on: |
        function Set-StartMenuToLeft {
            $registryPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            $name = "TaskbarAl"

            try {
                # Set the registry value to 0 (left alignment)
                Set-ItemProperty -Path $registryPath -Name $name -Value 0 -Force

                # Restart Explorer (Windows will auto-relaunch it)
                Stop-Process -Name explorer -Force

                Write-Host "âœ… Start menu alignment set to left."
            } catch {
                Write-Warning "âš ï¸ Failed to set Start menu alignment: $_"
            }
        }
      off: |
        function Set-StartMenuToCenter {
            $registryPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
            $name = "TaskbarAl"

            try {
                # Set the registry value to 1 (center alignment)
                Set-ItemProperty -Path $registryPath -Name $name -Value 1 -Force

                # Restart Explorer (it will auto-restart)
                Stop-Process -Name explorer -Force

                Write-Host "âœ… Start menu alignment set to center."
            } catch {
                Write-Warning "âš ï¸ Failed to set Start menu alignment: $_"
            }
        }
    show file extensions:
      on: |
        function Set-ShowFileExtensions {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set HideFileExt to 0 to show file extensions (DWORD)
                Set-ItemProperty -Path $regPath -Name HideFileExt -Value 0 -Type DWord
                Write-Host "âœ… File extensions will be visible (HideFileExt = 0)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply file extension visibility."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to set file extensions visibility: $_"
            }
        }
      off: |
        function Set-HideFileExtensions {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"

                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set HideFileExt to 1 to hide file extensions (DWORD)
                Set-ItemProperty -Path $regPath -Name HideFileExt -Value 1 -Type DWord
                Write-Host "âœ… File extensions will be hidden (HideFileExt = 1)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply hiding of file extensions."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to hide file extensions: $_"
            }
        }
    show hidden files:
      on: |
        function Set-ShowHiddenFiles {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set Hidden to 1 to show hidden files (DWORD)
                Set-ItemProperty -Path $regPath -Name Hidden -Value 1 -Type DWord
                Write-Host "âœ… Hidden files will be shown (Hidden = 1)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply hidden files visibility."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to set show hidden files: $_"
            }
        }
      off: |
        function Set-HideHiddenFiles {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set Hidden to 2 to hide hidden files (DWORD)
                Set-ItemProperty -Path $regPath -Name Hidden -Value 2 -Type DWord
                Write-Host "âœ… Hidden files will be hidden (Hidden = 2)."

                if (-not $NoRestart) {
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply hiding of hidden files."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to hide hidden files: $_"
            }
        }
    hide search box:
      on: |
        function Set-HideSearchBox {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search"
                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set SearchboxTaskbarMode to 0 to hide the search box (DWORD)
                Set-ItemProperty -Path $regPath -Name SearchboxTaskbarMode -Value 0 -Type DWord
                Write-Host "âœ… Search box will be hidden (SearchboxTaskbarMode = 0)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply hiding of search box."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to hide search box: $_"
            }
        }
      off: |
        function Set-ShowSearchBox {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search"
                # Ensure the key exists
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set SearchboxTaskbarMode to 2 to show the full search box (DWORD)
                Set-ItemProperty -Path $regPath -Name SearchboxTaskbarMode -Value 2 -Type DWord
                Write-Host "âœ… Search box will be shown (SearchboxTaskbarMode = 2)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply showing of search box."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to show search box: $_"
            }
        }
  date time:
    show seconds in taskbar:
      on: |
        function Set-ShowSecondsInTaskbar {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"

                # Ensure the key exists (the path should exist by default)
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set ShowSecondsInSystemClock to 1 to show seconds (DWORD)
                Set-ItemProperty -Path $regPath -Name ShowSecondsInSystemClock -Value 1 -Type DWord
                Write-Host "âœ… Taskbar clock will display seconds (ShowSecondsInSystemClock = 1)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply the seconds display."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to enable seconds in taskbar clock: $_"
            }
        }
      off: |
        function Set-HideSecondsInTaskbar {
            [CmdletBinding()]
            param (
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )

            try {
                $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"

                # Ensure the key exists (it normally does)
                if (-not (Test-Path $regPath)) {
                    New-Item -Path $regPath -Force | Out-Null
                }

                # Set ShowSecondsInSystemClock to 0 to hide seconds (DWORD)
                Set-ItemProperty -Path $regPath -Name ShowSecondsInSystemClock -Value 0 -Type DWord
                Write-Host "âœ… Taskbar clock will hide seconds (ShowSecondsInSystemClock = 0)."

                if (-not $NoRestart) {
                    # Restart Explorer so the change takes effect immediately
                    Stop-Process -Name explorer -Force
                    Write-Host "ðŸ” Explorer restarted to apply the change."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to hide seconds in taskbar clock: $_"
            }
        }
    set custom short date:
      on: |
        function Set-CustomShortDatePattern {
            [CmdletBinding()]
            param()

            $short_date_pattern = "yyyy-MM-dd-dddd"
            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Update the registry with the new short date pattern
                Set-ItemProperty -Path $reg_path -Name sShortDate -Value $short_date_pattern -ErrorAction Stop
                Write-Output "Short date pattern set to '$short_date_pattern'."

                # Define SendMessageTimeout P/Invoke only if not already defined
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "Failed to set short date pattern: $_"
            }
        }
      off: |
        function Reset-ShortDatePattern {
            [CmdletBinding()]
            param(
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )
            try {
                # Determine the user's current culture name
                $cultureName = [System.Threading.Thread]::CurrentThread.CurrentCulture.Name

                # Create a CultureInfo without user overrides to get the default pattern
                $defaultCulture = New-Object System.Globalization.CultureInfo($cultureName, $false)
                $defaultPattern = $defaultCulture.DateTimeFormat.ShortDatePattern

                # Update registry
                $regPath = "HKCU:\Control Panel\International"
                Set-ItemProperty -Path $regPath -Name sShortDate -Value $defaultPattern -ErrorAction Stop

                # Broadcast setting change
                Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        using System;
        using System.Runtime.InteropServices;
        public static class NativeMethods {
            [DllImport("user32.dll", SetLastError = true)]
            public static extern IntPtr SendMessageTimeout(IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam, uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
        }
        '@ | Out-Null
                $HWND_BROADCAST = [IntPtr]0xFFFF
                $WM_SETTINGCHANGE = 0x001A
                [UIntPtr]$outPtr = [UIntPtr]::Zero
                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    [UIntPtr]0,
                    "intl",
                    0x0002,
                    100,
                    [ref]$outPtr
                ) | Out-Null

                Write-Host "âœ… ShortDatePattern reset to default: '$defaultPattern'."

                if (-not $NoRestart) {
                    Write-Host "ðŸ” Restarting Explorer to apply default date format..."
                    Stop-Process -Name explorer -Force
                    Write-Host "âœ… Explorer restarted."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to reset short date pattern: $_"
            }
        }
    set long date pattern:
      on: |
        function Set-CustomLongDatePattern {
            [CmdletBinding()]
            param()

            $long_date_pattern = "yyyy-MM-dd-dddd"
            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Update the registry with the new long date pattern
                Set-ItemProperty -Path $reg_path -Name sLongDate -Value $long_date_pattern -ErrorAction Stop
                Write-Output "Long date pattern set to '$long_date_pattern'."

                # Define SendMessageTimeout only if not already defined
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "Failed to set long date pattern: $_"
            }
        }
      off: |
        function Reset-LongDatePattern {
            [CmdletBinding()]
            param(
                [switch]$NoRestart  # If specified, do not restart Explorer automatically
            )
            try {
                # Determine current culture and default long date pattern without user overrides
                $cultureName = [System.Threading.Thread]::CurrentThread.CurrentCulture.Name
                $defaultCulture = New-Object System.Globalization.CultureInfo($cultureName, $false)
                $defaultPattern = $defaultCulture.DateTimeFormat.LongDatePattern

                # Update registry
                $regPath = "HKCU:\Control Panel\International"
                Set-ItemProperty -Path $regPath -Name sLongDate -Value $defaultPattern -ErrorAction Stop

                Write-Host "âœ… LongDatePattern reset to default: '$defaultPattern'."

                if (-not $NoRestart) {
                    Write-Host "ðŸ” Restarting Explorer to apply the change..."
                    Stop-Process -Name explorer -Force
                    Write-Host "âœ… Explorer restarted."
                } else {
                    Write-Host "â„¹ï¸ Explorer restart skipped (use -NoRestart to prevent auto-restart)."
                }
            } catch {
                Write-Warning "âŒ Failed to reset long date pattern: $_"
            }
        }
    set custom time pattern:
      on: |
        function Set-CustomTimePattern {
            [CmdletBinding()]
            param()

            $time_format = "HH.mm.ss"   # Long time
            $short_time_format = "HH.mm.ss"  # Short time (with seconds)
            $time_separator = "."
            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Set long time, short time, and separator
                Set-ItemProperty -Path $reg_path -Name sTimeFormat -Value $time_format -ErrorAction Stop
                Set-ItemProperty -Path $reg_path -Name sShortTime -Value $short_time_format -ErrorAction Stop
                Set-ItemProperty -Path $reg_path -Name sTime -Value $time_separator -ErrorAction Stop

                Write-Output "âœ… Time format set:"
                Write-Output "   Long time  (sTimeFormat): $time_format"
                Write-Output "   Short time (sShortTime) : $short_time_format"
                Write-Output "   Time separator (sTime)  : $time_separator"

                # Broadcast setting change
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply time settings."
            }
            catch {
                Write-Error "âŒ Failed to set custom time pattern: $_"
            }
        }
      off: |
        function Reset-TimePatternToDefault {
            [CmdletBinding()]
            param()

            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Get current culture without user overrides
                $culture = [System.Globalization.CultureInfo]::CurrentCulture
                $default_culture = New-Object System.Globalization.CultureInfo($culture.Name, $false)
                $default_long_time = $default_culture.DateTimeFormat.LongTimePattern
                $default_short_time = $default_culture.DateTimeFormat.ShortTimePattern
                $default_time_separator = $default_culture.DateTimeFormat.TimeSeparator

                # Reset time patterns and separator
                Set-ItemProperty -Path $reg_path -Name sTimeFormat -Value $default_long_time -ErrorAction Stop
                Set-ItemProperty -Path $reg_path -Name sShortTime -Value $default_short_time -ErrorAction Stop
                Set-ItemProperty -Path $reg_path -Name sTime -Value $default_time_separator -ErrorAction Stop

                Write-Output "âœ… Time settings reset to system defaults:"
                Write-Output "   Long time  (sTimeFormat): $default_long_time"
                Write-Output "   Short time (sShortTime) : $default_short_time"
                Write-Output "   Time separator (sTime)  : $default_time_separator"

                # Broadcast setting change
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply default time settings."
            }
            catch {
                Write-Error "âŒ Failed to reset time pattern to defaults: $_"
            }
        }
    set 24-hour time format:
      on: |
        function Set-24HourTimeFormat {
            [CmdletBinding()]
            param()

            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Set the 24-hour format flag
                Set-ItemProperty -Path $reg_path -Name iTime -Value "1" -ErrorAction Stop

                Write-Output "âœ… Windows is now configured to use 24-hour time (iTime = 1)."

                # Optionally broadcast setting change to notify running apps
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xFFFF
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "âŒ Failed to set 24-hour time format: $_"
            }
        }
      off: |
        function Reset-12HourTimeFormat {
            [CmdletBinding()]
            param()

            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Set the 12-hour format flag
                Set-ItemProperty -Path $reg_path -Name iTime -Value "0" -ErrorAction Stop

                Write-Output "âœ… Windows is now configured to use 12-hour time (iTime = 0)."

                # Optionally broadcast setting change to notify running apps
                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xFFFF
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "âŒ Failed to reset to 12-hour time format: $_"
            }
        }
    set first day of week Monday:
      on: |
        function Set-FirstDayOfWeekMonday {
            [CmdletBinding()]
            param()

            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Set to Monday (0)
                Set-ItemProperty -Path $reg_path -Name iFirstDayOfWeek -Value "0" -ErrorAction Stop
                Write-Output "âœ… First day of the week set to Monday (iFirstDayOfWeek = 0)."

                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xFFFF
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "âŒ Failed to set first day of week: $_"
            }
        }
      off: |
        function Set-FirstDayOfWeekSunday {

            [CmdletBinding()]
            param()

            $reg_path = "HKCU:\Control Panel\International"

            try {
                # Set to Sunday (6)
                Set-ItemProperty -Path $reg_path -Name iFirstDayOfWeek -Value "6" -ErrorAction Stop
                Write-Output "âœ… First day of the week set to Sunday (iFirstDayOfWeek = 6)."

                if (-not ("Win32.NativeMethods" -as [type])) {
                    Add-Type -Namespace Win32 -Name NativeMethods -MemberDefinition @'
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        public static extern int SendMessageTimeout(
            int hWnd, uint Msg, int wParam, string lParam, uint fuFlags, uint uTimeout, out int lpdwResult);
        '@
                }

                $HWND_BROADCAST = 0xFFFF
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = 0

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    0,
                    "Intl",
                    $SMTO_ABORTIFHUNG,
                    100,
                    [ref]$result
                ) | Out-Null

                Write-Output "ðŸ”„ System broadcast completed to apply the setting."
            }
            catch {
                Write-Error "âŒ Failed to set first day of week: $_"
            }
        }
  ssh:
    enable: |
      function Enable-SSH {
          [CmdletBinding()]
          param ()

          $service_name = "sshd"

          while ($true) {
              $service = Get-Service -Name $service_name -ErrorAction SilentlyContinue

              if (-not $service) {
                  Write-Error "âŒ Service '$service_name' not found."
                  return
              }

              $status = $service.Status
              $start_mode = (Get-CimInstance -ClassName Win32_Service -Filter "Name='$service_name'").StartMode

              Write-Host "ðŸ”Ž Current State â€” Name: $($service.Name) | Status: $status | StartType: $start_mode"

              $changed = $false

              if ($start_mode -ne "Auto") {
                  Write-Host "âš™ï¸ Setting StartType to 'Automatic'..."
                  Set-Service -Name $service_name -StartupType Automatic
                  $changed = $true
              }

              if ($status -ne "Running") {
                  Write-Host "ðŸš€ Starting SSHD service..."
                  Start-Service -Name $service_name
                  $changed = $true
              }

              if (-not $changed) {
                  Write-Host "âœ… SSHD is Running and set to Automatic. Done."
                  break
              }

              Start-Sleep -Seconds 2
          }

          # Final confirmation in requested format
          Get-Service -Name $service_name | Select-Object Name, Status, StartType
      }
    firewall: |
      function Enable-SSHFirewallRule {
          [CmdletBinding()]
          param ()

          $port = 22
          $rule_name = "Allow-SSH"

          # Get active network profiles
          $active_profiles = (Get-NetConnectionProfile).NetworkCategory

          # Look for any enabled inbound rule that allows TCP port 22 AND includes the active profile
          $rule_covers_active_profile = Get-NetFirewallRule -Enabled True -Direction Inbound -Action Allow |
              Where-Object {
                  ($_ | Get-NetFirewallPortFilter).Protocol -eq "TCP" -and
                  ($_ | Get-NetFirewallPortFilter).LocalPort -eq "$port" -and
                  ($_ | Get-NetFirewallProfile).Profile -match $active_profiles
              }

          if (-not $rule_covers_active_profile) {
              Write-Host "ðŸ” No firewall rule allows SSH on port 22 for profile(s): $active_profiles. Creating '$rule_name'..."

              try {
                  New-NetFirewallRule -Name $rule_name -DisplayName "Allow SSH on Port 22" `
                      -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort $port `
                      -Profile Domain,Private,Public -ErrorAction Stop

                  # Post-creation verification
                  $rule = Get-NetFirewallRule -Name $rule_name -ErrorAction Stop
                  if ($rule.Enabled -eq 'True' -and $rule.Direction -eq 'Inbound' -and $rule.Action -eq 'Allow') {
                      Write-Host "âœ… Rule '$rule_name' successfully created and verified."
                  } else {
                      Write-Warning "âš ï¸ Rule '$rule_name' was created but doesn't match expected parameters."
                  }
              } catch {
                  Write-Error "âŒ Failed to create or verify rule '$rule_name': $_"
              }
          } else {
              Write-Host "âœ… SSH is already allowed on port 22 for profile(s): $active_profiles. No action needed."
          }
      }
general:
  date time:
    IANA time zone: |
      function Get-IanaTimeZone {
          $win_tz = (Get-TimeZone).Id
          $iana_tz = $null

          # Method 1: .NET TimeZoneInfo API (PowerShell 7.2+ / .NET 6+)
          if ([System.TimeZoneInfo].GetMethod("TryConvertWindowsIdToIanaId", [type[]]@([string],[string].MakeByRefType()))) {
              if ([System.TimeZoneInfo]::TryConvertWindowsIdToIanaId($win_tz, [ref] $iana_tz)) {
                  return $iana_tz
              }
          }

          # Method 2: WinRT Calendar API (Windows 10+)
          try {
              return [Windows.Globalization.Calendar,Windows.Globalization,ContentType=WindowsRuntime]::new().GetTimeZone()
          } catch {}

          # Method 3: Parse TimeZoneMapping.xml
          $map_path = Join-Path $Env:WinDir 'Globalization\Time Zone\TimeZoneMapping.xml'
          if (Test-Path $map_path) {
              $map_xml = [xml](Get-Content $map_path)
              $node = $map_xml.TimeZoneMapping.MapTZ | Where-Object { $_.WinID -eq $win_tz -and $_.Default -eq "true" }
              if ($node) {
                  return $node.TZID
              }
          }

          # Fallback to Windows ID
          return $win_tz
      }
    ISO week date: |
      function Get-IsoWeekDate {
          param (
              [datetime]$date = (Get-Date)
          )

          if ([System.Type]::GetType("System.Globalization.ISOWeek")) {
              $iso_week = [System.Globalization.ISOWeek]::GetWeekOfYear($date)
              $iso_year = [System.Globalization.ISOWeek]::GetYear($date)
          } else {
              $iso_day = (([int]$date.DayOfWeek + 6) % 7) + 1
              $weekThursday = $date.AddDays(4 - $iso_day)
              $iso_year = $weekThursday.Year
              $iso_week = [System.Globalization.CultureInfo]::InvariantCulture.Calendar.GetWeekOfYear(
                  $weekThursday,
                  [System.Globalization.CalendarWeekRule]::FirstFourDayWeek,
                  [System.DayOfWeek]::Monday
              )
          }

          $iso_day = (([int]$date.DayOfWeek + 6) % 7) + 1
          return "{0:0000}-W{1:000}-{2:000}" -f $iso_year, $iso_week, $iso_day
      }
    ISO ordinal date: |
      function Get-IsoOrdinalDate {
          [CmdletBinding()]
          param (
              [Parameter(ValueFromPipeline = $true)]
              [DateTime] $Date = (Get-Date)
          )

          process {
              # Format as YYYY-DDD (year and 3-digit day-of-year)
              $ordinal = "{0:yyyy}-{1:D3}" -f $Date, $Date.DayOfYear
              Write-Output $ordinal
          }
      }
    prompt for date time formatting: |
      function prompt {
          $now = Get-Date

          # Use high-precision timestamp (7 fractional digits)
          $timestamp = $now.ToString("yyyy-0MM-0dd 0HH.0mm.0ss.fffffff")

          $iana_tz = Get-IanaTimeZone
          $iso_week_date = Get-IsoWeekDate -date $now
          $iso_ordinal_date = Get-IsoOrdinalDate -date $now

          # Print formatted info to screen (timestamp + tz + ISO week + ordinal)
          Write-Host "$timestamp $iana_tz $iso_week_date $iso_ordinal_date" -ForegroundColor Green

          return "$PWD> "
      }
  terminal configuration:
    path management:
      add-to path: |
        function Add-ToPath {

            param (
                [Parameter(Mandatory = $true)]
                [string]$PathToAdd
            )

            try {
                # Resolve path (file or folder)
                $resolvedPath = Resolve-Path -Path $PathToAdd -ErrorAction Stop

                # Determine if it's a file or folder
                if (Test-Path $resolvedPath.Path -PathType Leaf) {
                    $targetPath = Split-Path -Path $resolvedPath.Path -Parent
                } else {
                    $targetPath = $resolvedPath.Path
                }

                # Normalize
                $normalizedPath = $targetPath.TrimEnd('\')

                # Get current system PATH
                $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
                $pathEntries = $currentPath.Split(';') | ForEach-Object { $_.TrimEnd('\') }

                if ($pathEntries -contains $normalizedPath) {
                    Write-Host "Path '$normalizedPath' is already in the system PATH."
                    return
                }

                # Prepend and set new system PATH
                $newPath = "$normalizedPath;$currentPath"
                [Environment]::SetEnvironmentVariable("Path", $newPath, "Machine")
                Write-Host "Path '$normalizedPath' added to the TOP of system PATH."

                # Broadcast the environment change
                $signature = @'
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,
            uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
        '@

                Add-Type -MemberDefinition $signature -Namespace Win32 -Name NativeMethods

                $HWND_BROADCAST = [IntPtr]0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = [UIntPtr]::Zero

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    [UIntPtr]::Zero,
                    "Environment",
                    $SMTO_ABORTIFHUNG,
                    5000,
                    [ref]$result
                ) | Out-Null

                Write-Host "Environment update broadcast sent."
            }
            catch {
                Write-Error "Failed to add path: $_"
            }
        }
      remove from path: |
        function Remove-FromPath {
            param (
                [Parameter(Mandatory = $true)]
                [string]$PathToRemove
            )

            try {
                # Resolve to absolute path
                $resolvedPath = Resolve-Path -Path $PathToRemove -ErrorAction Stop

                # If it's a file, get the directory
                if (Test-Path $resolvedPath.Path -PathType Leaf) {
                    $targetPath = Split-Path -Path $resolvedPath.Path -Parent
                } else {
                    $targetPath = $resolvedPath.Path
                }

                # Normalize the path (remove trailing slashes)
                $normalizedPath = $targetPath.TrimEnd('\')

                # Get current system PATH
                $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
                $pathEntries = $currentPath.Split(';') | ForEach-Object { $_.TrimEnd('\') }

                if ($pathEntries -notcontains $normalizedPath) {
                    Write-Host "Path '$normalizedPath' not found in system PATH."
                    return
                }

                # Remove the path
                $updatedPath = ($pathEntries | Where-Object { $_ -ne $normalizedPath }) -join ';'
                [Environment]::SetEnvironmentVariable("Path", $updatedPath, "Machine")
                Write-Host "Path '$normalizedPath' removed from system PATH."

                # Broadcast the environment variable change
                $signature = @'
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,
            uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
        '@

                Add-Type -MemberDefinition $signature -Namespace Win32 -Name NativeMethods

                $HWND_BROADCAST = [IntPtr]0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = [UIntPtr]::Zero

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    [UIntPtr]::Zero,
                    "Environment",
                    $SMTO_ABORTIFHUNG,
                    5000,
                    [ref]$result
                ) | Out-Null

                Write-Host "Environment update broadcast sent."
            }
            catch {
                Write-Error "Failed to remove path: $_"
            }
        }
      get system path: |
        function Get-SystemPath {
            [CmdletBinding()]
            param ()

            $path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
            return $path
        }
    ps module path management:
      add to ps module path: |
        function Add-ToPSModulePath {
            [CmdletBinding()]
            param (
                [Parameter(Mandatory = $true)]
                [string]$Directory
            )

            try {
                # Resolve and normalize the path
                $resolvedPath = (Resolve-Path -Path $Directory -ErrorAction Stop).Path.TrimEnd('\')

                # Get current system PSModulePath
                $currentSystemPath = [Environment]::GetEnvironmentVariable("PSModulePath", "Machine")
                $pathEntries = $currentSystemPath -split ';' | ForEach-Object { $_.TrimEnd('\') }

                if ($pathEntries -contains $resolvedPath) {
                    Write-Host "Path already in system PSModulePath: $resolvedPath"
                } else {
                    $newPath = "$currentSystemPath;$resolvedPath"
                    [Environment]::SetEnvironmentVariable("PSModulePath", $newPath, "Machine")
                    Write-Host "Added to system PSModulePath: $resolvedPath"

                    # Optional: Broadcast the environment change to running processes
                    $signature = @'
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,
            uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
        '@

                    Add-Type -MemberDefinition $signature -Namespace Win32 -Name NativeMethods
                    $HWND_BROADCAST = [IntPtr]0xffff
                    $WM_SETTINGCHANGE = 0x001A
                    $SMTO_ABORTIFHUNG = 0x0002
                    $result = [UIntPtr]::Zero

                    [Win32.NativeMethods]::SendMessageTimeout(
                        $HWND_BROADCAST,
                        $WM_SETTINGCHANGE,
                        [UIntPtr]::Zero,
                        "Environment",
                        $SMTO_ABORTIFHUNG,
                        5000,
                        [ref]$result
                    ) | Out-Null

                    Write-Host "Environment update broadcast sent."
                }
            } catch {
                Write-Error "Failed to add to PSModulePath: $_"
            }
        }
      remove from ps module path: |
        function Remove-FromPSModulePath {
            [CmdletBinding()]
            param (
                [Parameter(Mandatory = $true)]
                [string]$Directory
            )

            try {
                # Resolve and normalize the path
                $resolvedPath = (Resolve-Path -Path $Directory -ErrorAction Stop).Path.TrimEnd('\')

                # Get current system PSModulePath
                $currentSystemPath = [Environment]::GetEnvironmentVariable("PSModulePath", "Machine")
                $pathEntries = $currentSystemPath -split ';' | ForEach-Object { $_.TrimEnd('\') }

                if ($pathEntries -notcontains $resolvedPath) {
                    Write-Host "Path not found in system PSModulePath: $resolvedPath"
                    return
                }

                # Remove the path
                $updatedPath = ($pathEntries | Where-Object { $_ -ne $resolvedPath }) -join ';'
                [Environment]::SetEnvironmentVariable("PSModulePath", $updatedPath, "Machine")
                Write-Host "Removed from system PSModulePath: $resolvedPath"

                # Broadcast the environment change
                $signature = @'
        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam,
            uint fuFlags, uint uTimeout, out UIntPtr lpdwResult);
        '@

                Add-Type -MemberDefinition $signature -Namespace Win32 -Name NativeMethods
                $HWND_BROADCAST = [IntPtr]0xffff
                $WM_SETTINGCHANGE = 0x001A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = [UIntPtr]::Zero

                [Win32.NativeMethods]::SendMessageTimeout(
                    $HWND_BROADCAST,
                    $WM_SETTINGCHANGE,
                    [UIntPtr]::Zero,
                    "Environment",
                    $SMTO_ABORTIFHUNG,
                    5000,
                    [ref]$result
                ) | Out-Null

                Write-Host "Environment update broadcast sent."
            }
            catch {
                Write-Error "Failed to remove from PSModulePath: $_"
            }
        }
  miscellaneous:
    add domain admin user: |
      function Add-DomainAdminUser {

          param (

              [Parameter(Mandatory = $true)]
              [string]$username

          )

          $password = ConvertTo-SecureString "f" -AsPlainText -Force

          # Create the domain user
          New-ADUser `
              -Name $username `
              -SamAccountName $username `
              -UserPrincipalName "$username@corp.strength.local" `
              -AccountPassword $password `
              -Enabled $true `
              -PasswordNeverExpires $true `
              -Path "CN=Users,DC=corp,DC=strength,DC=local"

          # Add to Domain Admins
          Add-ADGroupMember -Identity "Domain Admins" -Members $username

          # Add to Remote Desktop Users
          Add-ADGroupMember -Identity "Remote Desktop Users" -Members $username

          Write-Host "User '$username' created and added to Domain Admins and Remote Desktop Users."
      }
    test is 64 bit: |
      function Test-Is64Bit {
          if ([Environment]::Is64BitOperatingSystem) {
              Write-Host "Your computer is 64-bit."
          } else {
              Write-Host "Your computer is 32-bit."
          }
      }
    create desktop shortcut: |
      function New-DesktopShortcut {
          [CmdletBinding()]
          param (
              [Parameter(Mandatory)]
              [string]$TargetPath,

              [Parameter()]
              [string]$ShortcutName = $(Split-Path $TargetPath -Leaf).Replace('.exe','') + ".lnk",

              [Parameter()]
              [string]$Description = "",

              [Parameter()]
              [int]$WindowStyle = 3,  # âœ… 3 = Maximized by default

              [Parameter()]
              [bool]$AllUsers = $true  # âœ… Default to All Users
          )

          if (-not (Test-Path $TargetPath)) {
              Write-Error "âŒ Target path does not exist: $TargetPath"
              return
          }

          $desktopPath = if ($AllUsers) {
              "$env:PUBLIC\Desktop"
          } else {
              [Environment]::GetFolderPath("Desktop")
          }

          $shortcutPath = Join-Path $desktopPath $ShortcutName

          $shell = New-Object -ComObject WScript.Shell
          $shortcut = $shell.CreateShortcut($shortcutPath)
          $shortcut.TargetPath = $TargetPath
          $shortcut.WorkingDirectory = Split-Path $TargetPath
          $shortcut.WindowStyle = $WindowStyle
          $shortcut.Description = $Description
          $shortcut.IconLocation = "$TargetPath, 0"
          $shortcut.Save()

          Write-Host "âœ… Shortcut created at: $shortcutPath"
      }
install:
  install with winget:
    Powershell 7: |
      function Install-PowerShell-7 {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of PowerShell 7..."

          $arguments = @(
              "install"
              "--id", "Microsoft.PowerShell"
              "--source", "winget"
              "--scope", "machine"
              "--silent"
              "--accept-package-agreements"
              "--accept-source-agreements"
          )

          try {
              Start-Process -FilePath "winget" -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… PowerShell 7 installed successfully."
          } catch {
              Write-Error "âŒ Failed to install PowerShell 7. Error: $_"
          }
      }
    VS code: |
      function Install-VSCode {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of Visual Studio Code..."

          $arguments = @(
              "install"
              "-e"
              "--id", "Microsoft.VisualStudioCode"
              "--scope", "machine"
              "--silent"
              "--accept-package-agreements"
              "--accept-source-agreements"
          )

          try {
              Start-Process -FilePath "winget" -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… Visual Studio Code installed successfully."
          } catch {
              Write-Error "âŒ Failed to install Visual Studio Code. Error: $_"
          }
      }
    7zip: |
      function Install-7Zip {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of 7-Zip..."

          $arguments = @(
              "install"
              "-e"
              "--id", "7zip.7zip"
              "--scope", "machine"
              "--silent"
              "--accept-package-agreements"
              "--accept-source-agreements"
          )

          try {
              Start-Process -FilePath "winget" -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… 7-Zip installed successfully."
          } catch {
              Write-Error "âŒ Failed to install 7-Zip. Error: $_"
          }
      }
    voidtools everything: |
      function Install-Voidtools-Everything {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of Voidtools Everything..."

          $arguments = @(
              "install"
              "-e"
              "--id", "voidtools.Everything"
              "--scope", "machine"
              "--silent"
              "--accept-package-agreements"
              "--accept-source-agreements"
          )

          try {
              Start-Process -FilePath "winget" -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… Voidtools Everything installed successfully."
          } catch {
              Write-Error "âŒ Failed to install Voidtools Everything. Error: $_"
          }
      }
    WinSCP: |
      function Install-WinSCP {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of WinSCP..."

          $arguments = @(
              "install"
              "-e"
              "--id", "WinSCP.WinSCP"
              "--scope", "machine"
              "--silent"
              "--accept-package-agreements"
              "--accept-source-agreements"
          )

          try {
              Start-Process -FilePath "winget" -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… WinSCP installed successfully."
          } catch {
              Write-Error "âŒ Failed to install WinSCP. Error: $_"
          }
      }
  install with choco:
    MobaXTerm: |
      function Install-MobaXterm {

          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of MobaXterm..."

          # Try to resolve choco path
          $chocoPath = Get-Command choco -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

          if (-not $chocoPath) {
              $defaultChoco = "C:\ProgramData\chocolatey\bin\choco.exe"
              if (Test-Path $defaultChoco) {
                  $chocoPath = $defaultChoco
              } else {
                  Write-Error "âŒ Chocolatey not found. Please install Chocolatey first."
                  return
              }
          }

          $arguments = @("install", "mobaxterm", "--yes")

          try {
              Start-Process -FilePath $chocoPath -ArgumentList $arguments -Wait -NoNewWindow

              # Confirm installation
              $isInstalled = & $chocoPath list --local-only | Select-String -Pattern '^mobaxterm'

              if ($isInstalled) {
                  Write-Host "âœ… MobaXterm installed successfully."
              } else {
                  Write-Warning "âš ï¸ MobaXterm install completed, but it may not be installed correctly."
              }

          } catch {
              Write-Error "âŒ Failed to install MobaXterm. Error: $_"
          }
      }
    Go: |
      function Install-Go {

          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of Go..."

          # Resolve choco path
          $chocoPath = Get-Command choco -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

          if (-not $chocoPath) {
              $defaultChoco = "C:\ProgramData\chocolatey\bin\choco.exe"
              if (Test-Path $defaultChoco) {
                  $chocoPath = $defaultChoco
              } else {
                  Write-Error "âŒ Chocolatey not found. Please install Chocolatey first."
                  return
              }
          }

          $arguments = @("install", "golang", "--yes")

          try {
              Start-Process -FilePath $chocoPath -ArgumentList $arguments -Wait -NoNewWindow

              # Verify installation
              $isInstalled = & $chocoPath list --local-only | Select-String -Pattern '^golang'

              if ($isInstalled) {
                  Write-Host "âœ… Go installed successfully."
              } else {
                  Write-Warning "âš ï¸ Installation completed, but Go may not be fully installed."
              }

          } catch {
              Write-Error "âŒ Failed to install Go. Error: $_"
          }
      }
    Notepad++: |
      function Install-NotepadPP {

          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of Notepad++..."

          # Resolve Chocolatey path
          $chocoPath = Get-Command choco -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

          if (-not $chocoPath) {
              $defaultChoco = "C:\ProgramData\chocolatey\bin\choco.exe"
              if (Test-Path $defaultChoco) {
                  $chocoPath = $defaultChoco
              } else {
                  Write-Error "âŒ Chocolatey not found. Please install Chocolatey first."
                  return
              }
          }

          $arguments = @("install", "notepadplusplus", "--yes")

          try {
              Start-Process -FilePath $chocoPath -ArgumentList $arguments -Wait -NoNewWindow

              # Verify installation
              $isInstalled = & $chocoPath list --local-only | Select-String -Pattern '^notepadplusplus'

              if ($isInstalled) {
                  Write-Host "âœ… Notepad++ installed successfully."
              } else {
                  Write-Warning "âš ï¸ Install command ran, but Notepad++ may not be fully installed."
              }

          } catch {
              Write-Error "âŒ Failed to install Notepad++. Error: $_"
          }
      }
    SQLite Browser: |
      function Install-SQLiteBrowser {

          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of DB Browser for SQLite..."

          # Resolve Chocolatey path
          $chocoPath = Get-Command choco -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

          if (-not $chocoPath) {
              $defaultChoco = "C:\ProgramData\chocolatey\bin\choco.exe"
              if (Test-Path $defaultChoco) {
                  $chocoPath = $defaultChoco
              } else {
                  Write-Error "âŒ Chocolatey not found. Please install Chocolatey first."
                  return
              }
          }

          $arguments = @("install", "sqlitebrowser", "--yes")

          try {
              Start-Process -FilePath $chocoPath -ArgumentList $arguments -Wait -NoNewWindow

              # Verify installation
              $isInstalled = & $chocoPath list --local-only | Select-String -Pattern '^sqlitebrowser'

              if ($isInstalled) {
                  Write-Host "âœ… DB Browser for SQLite installed successfully."
              } else {
                  Write-Warning "âš ï¸ Install completed, but DB Browser for SQLite may not be fully installed."
              }

          } catch {
              Write-Error "âŒ Failed to install DB Browser for SQLite. Error: $_"
          }
      }
    Java: |
      function Install-Java {

          [CmdletBinding()]
          param (
              [string]$PackageName = "temurin21"
          )

          Write-Host "ðŸš€ Starting installation of Java package: $PackageName..."

          # Resolve Chocolatey path
          $chocoPath = Get-Command choco -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source
          if (-not $chocoPath) {
              $defaultChoco = "C:\ProgramData\chocolatey\bin\choco.exe"
              if (Test-Path $defaultChoco) {
                  $chocoPath = $defaultChoco
              } else {
                  Write-Error "âŒ Chocolatey not found. Please install Chocolatey first."
                  return
              }
          }

          $arguments = @("install", $PackageName, "--yes")

          try {
              Start-Process -FilePath $chocoPath -ArgumentList $arguments -Wait -NoNewWindow

              # Confirm installation
              $isInstalled = & $chocoPath list --local-only | Select-String -Pattern "^\Q$PackageName\E"
              if ($isInstalled) {
                  Write-Host "âœ… Java ($PackageName) installed successfully."
              } else {
                  Write-Warning "âš ï¸ Install completed, but $PackageName may not be fully installed."
              }

              # Set JAVA_HOME
              $javaHomePath = $null

              if ($PackageName -ieq "temurin21") {
                  $javaHomePath = "C:\Program Files\Eclipse Adoptium\jdk-21.0.6.7-hotspot"
              } else {
                  $jdkDir = Get-ChildItem "C:\Program Files\Eclipse Adoptium\" -Directory |
                            Where-Object { $_.Name -like "jdk*" } |
                            Sort-Object LastWriteTime -Descending |
                            Select-Object -First 1
                  if ($jdkDir) {
                      $javaHomePath = $jdkDir.FullName
                  }
              }

              if ($javaHomePath -and (Test-Path $javaHomePath)) {
                  [Environment]::SetEnvironmentVariable("JAVA_HOME", $javaHomePath, [System.EnvironmentVariableTarget]::Machine)
                  Write-Host "ðŸŒ± JAVA_HOME auto-set to: $javaHomePath"
              } else {
                  Write-Warning "âš ï¸ Could not determine JAVA_HOME path. You may need to set it manually."
              }

          } catch {
              Write-Error "âŒ Failed to install Java ($PackageName). Error: $_"
          }
      }
  install with msiexec or Start-Process:
    Cherry tree: |
      function Install-CherryTree {
          [CmdletBinding()]
          param (
              [Parameter(Mandatory = $true)]
              [string]$log,

              [Parameter(Mandatory = $true)]
              [string]$installPath
          )

          # Logging helper
          function Write-Log {
              param ([string]$message)
              $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              "$timestamp`t$message" | Out-File -FilePath $log -Append -Encoding UTF8
          }

          Write-Host "ðŸš€ Starting CherryTree installation..."
          Write-Host "ðŸ“ Log path: $log"
          Write-Host "ðŸ“ Install path: $installPath"

          # Ensure directories exist
          $logDir = Split-Path $log -Parent
          if (-not (Test-Path $logDir)) {
              New-Item -ItemType Directory -Path $logDir -Force | Out-Null
          }

          $installDirParent = Split-Path $installPath -Parent
          if (-not (Test-Path $installDirParent)) {
              New-Item -ItemType Directory -Path $installDirParent -Force | Out-Null
          }

          # Use dynamic path to installer
          $installerName = "cherrytree_1.5.0.0_win64_setup.exe"
          $installer = Join-Path $installPath $installerName
          if (-not (Test-Path $installer)) {
              Write-Log "âŒ Installer not found at $installer"
              Write-Error "âŒ Installer not found at $installer"
              return
          }

          # Install arguments
          $arguments = @(
              "/VERYSILENT"
              "/SUPPRESSMSGBOXES"
              "/NORESTART"
              "/SP-"
              "/DIR=$installPath"
              "/LOG=$log"
          )

          $start = Get-Date
          Write-Log "ðŸš€ Install started"
          Write-Host "â±ï¸ Start: $start"

          try {
              Start-Process -FilePath $installer -ArgumentList $arguments -Wait -NoNewWindow

              $end = Get-Date
              $duration = $end - $start

              Write-Log "âœ… Install completed"
              Write-Log "â±ï¸ Start: $start"
              Write-Log "âœ… End:   $end"
              Write-Log "ðŸ§® Duration: $($duration.ToString())"

              Write-Host "âœ… End:   $end"
              Write-Host "ðŸ§® Duration: $($duration.ToString())"
          } catch {
              $end = Get-Date
              $duration = $end - $start

              Write-Log "âŒ Install failed: $_"
              Write-Log "â±ï¸ Start: $start"
              Write-Log "âŒ End:   $end"
              Write-Log "ðŸ§® Duration: $($duration.ToString())"

              Write-Error "âŒ Installation failed"
              Write-Host "â±ï¸ Start: $start"
              Write-Host "âŒ End:   $end"
              Write-Host "ðŸ§® Duration: $($duration.ToString())"
          }
      }
    Miniconda: |
      function Install-Miniconda {

          [CmdletBinding()]
          param (
              [Parameter(Mandatory = $true)]
              [string]$InstallerPath
          )

          # Define installation paths
          $installDir = "C:\ProgramData\Miniconda3"
          $condaExe = Join-Path $installDir "Scripts\conda.exe"
          $pythonExe = Join-Path $installDir "python.exe"

          # Check if installer exists
          if (-not (Test-Path -Path $InstallerPath)) {
              Write-Error "âŒ Installer not found at: $InstallerPath"
              return
          }

          Write-Host "ðŸ“¦ Installing Miniconda from: $InstallerPath"

          # Define install arguments
          $arguments = @(
              "/S",                                # Silent install
              "/InstallationType=AllUsers",        # System-wide
              "/RegisterPython=1",                 # Set as system Python
              "/D=$installDir"                     # Install location (must be last)
          )

          try {
              # Run installer
              Start-Process -FilePath $InstallerPath -ArgumentList $arguments -Wait -NoNewWindow
              Write-Host "âœ… Miniconda installed successfully."

              # --- Verification ---
              Write-Host "`nâœ… Miniconda installed to: $installDir"

              if (Test-Path $pythonExe) {
                  Write-Host "ðŸ Python version:"
                  & $pythonExe --version
              } else {
                  Write-Warning "âš ï¸ Python not found at expected path: $pythonExe"
              }

              if (Test-Path $condaExe) {
                  Write-Host "ðŸ“¦ Conda version:"
                  & $condaExe --version

                  # Clear Conda cache
                  & $condaExe clean --all --yes
                  Write-Host "ðŸ§¹ Conda cache cleaned."
              } else {
                  Write-Warning "âš ï¸ Conda not found at expected path: $condaExe"
              }

          } catch {
              Write-Error "âŒ Installation failed: $_"
          }
      }
  install with miscellaneous (neither winget nor choco nor Start-Process nor msiexec):
    choco: |
      function Install-Choco {
          [CmdletBinding()]
          param ()

          Write-Host "ðŸš€ Starting installation of Chocolatey..."

          $installScript = 'https://community.chocolatey.org/install.ps1'

          try {
              Set-ExecutionPolicy Bypass -Scope Process -Force

              # Secure protocol
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072

              # Run install script
              iex ((New-Object System.Net.WebClient).DownloadString($installScript))

              Write-Host "âœ… Chocolatey installed successfully."
          } catch {
              Write-Error "âŒ Failed to install Chocolatey. Error: $_"
          }
      }
